"""
Fyers WebSocket Manager for Real-Time Market Data
================================================
Implements real-time market data streaming using Fyers WebSocket API v3
"""

import logging
import threading
import time
from datetime import datetime
from typing import Dict, List, Optional, Callable
from dataclasses import dataclass
import json

from fyers_apiv3.FyersWebsocket import data_ws
from src.config.settings import FYERS_CLIENT_ID
import os

logger = logging.getLogger(__name__)

@dataclass
class MarketData:
    """Real-time market data structure."""
    symbol: str
    ltp: float
    volume: int
    timestamp: datetime
    change: float = 0.0
    change_percent: float = 0.0

class FyersWebSocketManager:
    """Manages Fyers WebSocket connection for real-time market data."""
    
    def __init__(self, symbols: List[str]):
        self.symbols = symbols
        self.access_token = self._get_access_token()
        self.data_callbacks: List[Callable] = []
        self.live_data: Dict[str, MarketData] = {}
        self.is_connected = False
        self.is_running = False
        self._lock = threading.Lock()
        
        # Initialize WebSocket
        self.fyers_socket = None
        self._initialize_socket()
        
        logger.info(f"ðŸ”„ Fyers WebSocket Manager initialized for {len(symbols)} symbols")
    
    def _get_access_token(self) -> str:
        """Get access token from environment."""
        try:
            access_token = os.getenv("FYERS_ACCESS_TOKEN")
            if access_token:
                return f"{FYERS_CLIENT_ID}:{access_token}"
            else:
                logger.error("No FYERS_ACCESS_TOKEN in environment")
                return None
        except Exception as e:
            logger.error(f"Failed to get access token: {e}")
            return None
    
    def _initialize_socket(self):
        """Initialize Fyers WebSocket connection."""
        try:
            if not self.access_token:
                logger.error("No access token available for WebSocket")
                return
                
            self.fyers_socket = data_ws.FyersDataSocket(
                access_token=self.access_token,
                log_path="logs/websocket/",
                litemode=True,  # Enable lite mode for faster LTP updates
                write_to_file=False,
                reconnect=True,
                on_connect=self._on_connect,
                on_close=self._on_close,
                on_error=self._on_error,
                on_message=self._on_message
            )
            logger.info("âœ… Fyers WebSocket socket initialized")
        except Exception as e:
            logger.error(f"âŒ Failed to initialize Fyers WebSocket: {e}")
            raise
    
    def _on_connect(self):
        """Callback when WebSocket connects."""
        logger.info("ðŸ”— Fyers WebSocket connected")
        self.is_connected = True
        
        # Subscribe to symbols
        try:
            self.fyers_socket.subscribe(
                symbols=self.symbols,
                data_type="SymbolUpdate"
            )
            logger.info(f"ðŸ“¡ Subscribed to {len(self.symbols)} symbols")
            
            # Keep the socket running
            self.fyers_socket.keep_running()
        except Exception as e:
            logger.error(f"âŒ Failed to subscribe to symbols: {e}")
    
    def _on_message(self, message):
        """Callback when WebSocket receives a message."""
        try:
            if isinstance(message, list):
                for data in message:
                    self._process_market_data(data)
            else:
                self._process_market_data(message)
        except Exception as e:
            logger.error(f"âŒ Error processing WebSocket message: {e}")
    
    def _process_market_data(self, data: Dict):
        """Process incoming market data."""
        try:
            symbol = data.get('symbol', '')
            ltp = float(data.get('ltp', 0))
            volume = int(data.get('volume', 0))
            timestamp = datetime.now()
            
            # Calculate change if we have previous data
            change = 0.0
            change_percent = 0.0
            if symbol in self.live_data:
                prev_ltp = self.live_data[symbol].ltp
                if prev_ltp > 0:
                    change = ltp - prev_ltp
                    change_percent = (change / prev_ltp) * 100
            
            # Create market data object
            market_data = MarketData(
                symbol=symbol,
                ltp=ltp,
                volume=volume,
                timestamp=timestamp,
                change=change,
                change_percent=change_percent
            )
            
            # Update live data
            with self._lock:
                self.live_data[symbol] = market_data
            
            # Notify callbacks
            for callback in self.data_callbacks:
                try:
                    callback(market_data)
                except Exception as e:
                    logger.error(f"âŒ Error in data callback: {e}")
            
            logger.debug(f"ðŸ“Š {symbol}: {ltp} ({change:+.2f}, {change_percent:+.2f}%)")
            
        except Exception as e:
            logger.error(f"âŒ Error processing market data: {e}")
    
    def _on_error(self, message):
        """Callback when WebSocket encounters an error."""
        logger.error(f"âŒ Fyers WebSocket error: {message}")
        self.is_connected = False
    
    def _on_close(self, message):
        """Callback when WebSocket connection closes."""
        logger.warning(f"ðŸ”Œ Fyers WebSocket closed: {message}")
        self.is_connected = False
    
    def start(self):
        """Start the WebSocket connection."""
        if self.is_running:
            logger.warning("WebSocket is already running")
            return
        
        try:
            self.is_running = True
            # Start WebSocket in a separate thread
            self.websocket_thread = threading.Thread(
                target=self._run_websocket,
                daemon=True
            )
            self.websocket_thread.start()
            logger.info("ðŸš€ Fyers WebSocket started")
        except Exception as e:
            logger.error(f"âŒ Failed to start WebSocket: {e}")
            self.is_running = False
    
    def _run_websocket(self):
        """Run the WebSocket connection."""
        try:
            self.fyers_socket.connect()
        except Exception as e:
            logger.error(f"âŒ WebSocket connection failed: {e}")
            self.is_connected = False
    
    def stop(self):
        """Stop the WebSocket connection."""
        self.is_running = False
        if self.fyers_socket:
            try:
                pass  # Fyers WebSocket auto-closes when is_running=False
            except Exception as e:
                logger.error(f"âŒ Error closing WebSocket: {e}")
        logger.info("ðŸ›‘ Fyers WebSocket stopped")
    
    def add_data_callback(self, callback: Callable):
        """Add a callback function for market data updates."""
        self.data_callbacks.append(callback)
        logger.info(f"ðŸ“ž Added data callback: {callback.__name__}")
    
    def get_current_price(self, symbol: str) -> Optional[float]:
        """Get current price for a symbol."""
        with self._lock:
            if symbol in self.live_data:
                return self.live_data[symbol].ltp
        return None
    
    def get_live_data(self, symbol: str) -> Optional[MarketData]:
        """Get complete live data for a symbol."""
        with self._lock:
            return self.live_data.get(symbol)
    
    def get_all_live_data(self) -> Dict[str, MarketData]:
        """Get all live market data."""
        with self._lock:
            return self.live_data.copy()
    
    def get_connection_status(self) -> Dict[str, any]:
        """Get WebSocket connection status."""
        return {
            "is_connected": self.is_connected,
            "is_running": self.is_running,
            "symbols_count": len(self.symbols),
            "live_data_count": len(self.live_data),
            "callbacks_count": len(self.data_callbacks)
        }
    
    def update_symbols(self, new_symbols: List[str]):
        """Update the list of symbols to subscribe to."""
        try:
            self.symbols = new_symbols
            if self.is_connected and self.fyers_socket:
                # Unsubscribe from old symbols and subscribe to new ones
                self.fyers_socket.subscribe(
                    symbols=new_symbols,
                    data_type="SymbolUpdate"
                )
                logger.info(f"ðŸ”„ Updated symbols subscription to {len(new_symbols)} symbols")
        except Exception as e:
            logger.error(f"âŒ Failed to update symbols: {e}")

# Global WebSocket manager instance
_websocket_manager: Optional[FyersWebSocketManager] = None

def get_websocket_manager(symbols: List[str] = None) -> FyersWebSocketManager:
    """Get or create the global WebSocket manager instance."""
    global _websocket_manager
    
    if _websocket_manager is None:
        if symbols is None:
            symbols = [
                "NSE:NIFTY50-INDEX",
                "NSE:NIFTYBANK-INDEX", 
                "NSE:FINNIFTY-INDEX",
                "NSE:RELIANCE-EQ",
                "NSE:HDFCBANK-EQ"
            ]
        _websocket_manager = FyersWebSocketManager(symbols)
    
    return _websocket_manager

def start_websocket(symbols: List[str] = None):
    """Start the global WebSocket manager."""
    manager = get_websocket_manager(symbols)
    manager.start()
    return manager

def stop_websocket():
    """Stop the global WebSocket manager."""
    global _websocket_manager
    if _websocket_manager:
        _websocket_manager.stop()
        _websocket_manager = None
