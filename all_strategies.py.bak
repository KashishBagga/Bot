#!/usr/bin/env python3
"""
Run all trading strategies at once and save results to database
"""
import sys
import traceback
import os
import time
from datetime import datetime, timedelta
import argparse
import backoff
import pandas as pd

def check_dependencies():
    """Check if all required dependencies are installed"""
    try:
        print("Checking required dependencies...")
        import fyers_apiv3
        import pandas
        import ta
        import backoff
        import numpy
        import dotenv
        print("âœ… All required dependencies are installed")
        return True
    except ImportError as e:
        print(f"âŒ Missing dependency: {e}")
        print("Please install all required dependencies with:")
        print("pip install fyers-apiv3 requests pandas numpy ta SQLAlchemy schedule pytz python-dotenv backoff")
        return False

def check_fyers_credentials():
    """Check if Fyers API credentials are properly set"""
    from dotenv import load_dotenv
    load_dotenv()
    
    # Check essential credentials
    print("Checking Fyers API credentials...")
    client_id = os.getenv("FYERS_CLIENT_ID")
    access_token = os.getenv("FYERS_ACCESS_TOKEN")
    
    if not client_id or not access_token:
        print("âŒ Missing Fyers API credentials")
        print("Please run test_fyers.py first to set up your credentials")
        return False
    
    print(f"âœ… Found Fyers credentials for client ID {client_id}")
    return True

@backoff.on_exception(backoff.expo, Exception, max_tries=3)
def fetch_candles(symbol, fyers, resolution="15", range_from=None, range_to=None):
    """
    Fetch historical candle data from Fyers API with improved error handling
    
    Args:
        symbol: The symbol to fetch data for (e.g., "NSE:NIFTY50-INDEX")
        fyers: The Fyers API client
        resolution: The timeframe resolution (1, 5, 15, D, W, M)
        range_from: Start date in YYYY-MM-DD format or timestamp
        range_to: End date in YYYY-MM-DD format or timestamp
    
    Returns:
        DataFrame with OHLCV data
    """
    # Set default date range if not provided - use a shorter recent period
    if not range_from:
        range_from = (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d')
    if not range_to:
        range_to = datetime.now().strftime('%Y-%m-%d')
    
    print(f"Fetching data for {symbol} from {range_from} to {range_to} with resolution {resolution}")
    
    # Try a simpler approach with direct date strings
    try:
        data = {
            "symbol": symbol,
            "resolution": resolution,
            "date_format": "1",  # Unix timestamp
            "range_from": range_from,
            "range_to": range_to,
            "cont_flag": "1"
        }
        
        print(f"Request data: {data}")
        response = fyers.history(data)
        
        # Check if response contains error
        if isinstance(response, dict) and 'code' in response and response['code'] != 200:
            error_code = response.get('code')
            error_message = response.get('message', 'Unknown error')
            print(f"API Error: {error_code} - {error_message}")
            
            # Try a shorter date range (last 7 days)
            print("Trying with a shorter date range (last 7 days)...")
            short_range_from = (datetime.now() - timedelta(days=7)).strftime('%Y-%m-%d')
            short_range_to = datetime.now().strftime('%Y-%m-%d')
            
            data = {
                "symbol": symbol,
                "resolution": resolution,
                "date_format": "1",
                "range_from": short_range_from,
                "range_to": short_range_to,
                "cont_flag": "1"
            }
            
            print(f"New request data: {data}")
            response = fyers.history(data)
            
            if isinstance(response, dict) and 'code' in response and response['code'] != 200:
                raise Exception(f"Failed to fetch data: {response.get('message')}")
        
        # Check if candles exist in the response
        candles = response.get('candles')
        if not candles:
            raise Exception(f"No candle data fetched for {symbol}")
            
        print(f"âœ… Successfully fetched {len(candles)} candles for {symbol}")
        df = pd.DataFrame(candles, columns=["time", "open", "high", "low", "close", "volume"])
        df['time'] = pd.to_datetime(df['time'], unit='s')
        return df
        
    except Exception as e:
        print(f"â— Error fetching candles: {e}")
        raise

def get_available_strategies():
    """Get all available strategies from src/strategies directory"""
    # Import strategies from src.strategies
    sys.path.append(os.path.dirname(os.path.abspath(__file__)))
    
    # Get available strategies from the src.strategies module
    try:
        from src.strategies import get_available_strategies
        strategies = get_available_strategies()
        
        # Add function-based strategies from old strategies directory
        strategies_dir = os.path.join(os.path.dirname(__file__), "strategies")
        if os.path.exists(strategies_dir):
            for file in os.listdir(strategies_dir):
                if file.endswith(".py") and not file.startswith("__"):
                    strategy_name = file[:-3]  # Remove .py extension
                    if strategy_name not in strategies:
                        strategies.append(strategy_name)
        
        return strategies
    except ImportError:
        print("âŒ Could not import strategies module")
        return []

def run_all_strategies(days_back=5, resolution="15", save_to_db=True, symbols=None):
    """Run all available strategies at once"""
    # Check dependencies first
    if not check_dependencies():
        return False
        
    # Check Fyers credentials
    if not check_fyers_credentials():
        return False
    
    # Get all available strategies
    strategies = get_available_strategies()
    
    if not strategies:
        print("âŒ No strategies found")
        return False
    
    print(f"ðŸ”„ Found {len(strategies)} strategies to run")
    
    # If we're saving to the database, initialize all tables now
    if save_to_db:
        try:
            from db import ensure_strategy_tables_exist
            ensure_strategy_tables_exist(strategies)
        except Exception as e:
            print(f"Warning: Failed to pre-create strategy tables: {e}")
    
    # Process symbols if not provided
    if not symbols:
        symbols = {
            "NSE:NIFTY50-INDEX": "NIFTY50",
            "NSE:NIFTYBANK-INDEX": "BANKNIFTY"
        }
        
    # Import the required modules
    from fyers_apiv3 import fyersModel
    from dotenv import load_dotenv
    import pandas as pd
    from ta.trend import EMAIndicator
    from ta.momentum import RSIIndicator
    from ta.trend import MACD
    from ta.volatility import AverageTrueRange, BollingerBands
    
    load_dotenv()
    
    # Get Fyers API credentials
    client_id = os.getenv("FYERS_CLIENT_ID")
    access_token = os.getenv("FYERS_ACCESS_TOKEN")
    
    print("ðŸ”„ Initializing Fyers client...")
    fyers = fyersModel.FyersModel(token=access_token, is_async=False, client_id=client_id, log_path="")
    
    # Use a recent time period (last X days)
    end_date = datetime.now().strftime('%Y-%m-%d')
    start_date = (datetime.now() - timedelta(days=days_back)).strftime('%Y-%m-%d')
    
    print(f"ðŸ“Š Fetching data for all strategies from {start_date} to {end_date} with {resolution} min candles")
    
    # Fetch data for all symbols
    dataframes = {}
    for symbol, index_name in symbols.items():
        try:
            print(f"\nðŸ“ˆ Processing {index_name}...")
            
            # Fetch data from Fyers
            df = fetch_candles(symbol, fyers, resolution=resolution, range_from=start_date, range_to=end_date)
            
            if df.empty:
                print(f"â— No candles available for {index_name}")
                continue
            
            print(f"âœ… Successfully fetched {len(df)} candles for {index_name}")
            
            # Pre-calculate common indicators used by most strategies
            # EMA
            df['ema_9'] = EMAIndicator(df['close'], window=9).ema_indicator()
            df['ema_21'] = EMAIndicator(df['close'], window=21).ema_indicator()
            df['ema_20'] = EMAIndicator(df['close'], window=20).ema_indicator()
            
            # Add a generic 'ema' field - use ema_20 as default for strategies that expect this field
            df['ema'] = df['ema_20']
            
            # RSI
            df['rsi'] = RSIIndicator(df['close'], window=14).rsi()
            
            # MACD
            macd = MACD(df['close'])
            df['macd'] = macd.macd()
            df['macd_signal'] = macd.macd_signal()
            df['macd_diff'] = macd.macd_diff()
            
            # ATR
            df['atr'] = AverageTrueRange(df['high'], df['low'], df['close'], window=14).average_true_range()
            
            # Bollinger Bands
            bb = BollingerBands(df['close'])
            df['bollinger_upper'] = bb.bollinger_hband()
            df['bollinger_lower'] = bb.bollinger_lband()
            df['bollinger_mid'] = bb.bollinger_mavg()
            
            # Display sample data
            # print("\nðŸ“Š Sample Data:")
            # print(df[['time', 'open', 'high', 'low', 'close', 'ema_20', 'ema', 'rsi', 'atr']].tail(5))
            
            # Store the dataframe for later use with all strategies
            dataframes[index_name] = df
            
        except Exception as e:
            print(f"âŒ Error processing {index_name}: {e}")
            traceback.print_exc()
    
    if not dataframes:
        print("âŒ No data available to run strategies")
        return False
    
    # Import our strategy modules
    sys.path.append(os.path.dirname(os.path.abspath(__file__)))
    
    # Now run each strategy with the fetched data
    results = {}
    start_time = time.time()
    
    for strategy_name in strategies:
        try:
            print(f"\n====== Running strategy: {strategy_name} ======")
            strategy_results = {}
            
            for index_name, df in dataframes.items():
                try:
                    # print(f"\nðŸ”„ Analyzing {index_name} with strategy '{strategy_name}'...")
                    
                    # Track all signals for database logging
                    all_signals = []
                    signal_count = {"NO TRADE": 0, "BUY CALL": 0, "BUY PUT": 0}
                    
                    # For running our new class-based strategies from src
                    if os.path.exists(f"src/strategies/{strategy_name}.py"):
                        # print(f"ðŸ”„ Using class-based strategy from src/strategies/{strategy_name}.py")
                        from src.strategies import get_strategy_class
                        strategy_class = get_strategy_class(strategy_name)
                        if strategy_class:
                            strategy = strategy_class()
                            df_with_indicators = strategy.add_indicators(df.copy())
                            
                            # Generate signals for all candles in the dataframe
                            candle_count = len(df_with_indicators)
                            # print(f"Generating signals for {candle_count} candles...")
                            
                            # For very large datasets, just print samples and count signals
                            signal_samples = min(10, candle_count)
                            print_interval = max(1, candle_count // 10)  # Print 10% of signals
                            
                            # Process all candles
                            for i in range(candle_count):
                                candle_data = df_with_indicators.iloc[i:i+1]
                                signal_result = strategy.analyze(candle_data, index_name=index_name)
                                
                                # Safe access to values - some strategies might return different keys
                                price = signal_result.get('price', df_with_indicators.iloc[i]['close'])
                                signal = signal_result.get('signal', 'NO TRADE')
                                confidence = signal_result.get('confidence', 'Low')
                                
                                # Count signal types
                                signal_count[signal] = signal_count.get(signal, 0) + 1
                                
                                # Record the signal
                                signal_info = {
                                    'time': df_with_indicators.iloc[i]['time'].strftime('%Y-%m-%d %H:%M:%S'),
                                    'signal': signal,
                                    'price': price,
                                    'confidence': confidence,
                                    'index_name': index_name  # Explicitly set index_name
                                }
                                
                                # Add other fields available in signal_result
                                for key, value in signal_result.items():
                                    if key not in ['time'] and key not in signal_info:
                                        signal_info[key] = value
                                
                                all_signals.append(signal_info)
                                
                                # Print some samples (last few and some distributed across the dataset)
                                if i >= candle_count - signal_samples or i % print_interval == 0:
                                    # print(f"Time: {df_with_indicators.iloc[i]['time']} - Signal: {signal} (Price: {price:.2f})")
                                    pass
                        else:
                            print(f"âŒ Strategy class '{strategy_name}' not found in src/strategies")
                            continue
                    
                    # For running our old function-based strategies
                    elif os.path.exists(f"strategies/{strategy_name}.py"):
                        print(f"ðŸ”„ Using function-based strategy from strategies/{strategy_name}.py")
                        try:
                            # Import the module (handles both naming patterns)
                            module = __import__(f"strategies.{strategy_name}", fromlist=[strategy_name])
                            
                            # First try with the exact function name
                            strategy_func = getattr(module, strategy_name, None)
                            
                            # If not found, try with strategy_ prefix for backward compatibility
                            if strategy_func is None and not strategy_name.startswith("strategy_"):
                                strategy_func = getattr(module, f"strategy_{strategy_name}", None)
                            
                            # If still not found, try removing strategy_ prefix
                            if strategy_func is None and strategy_name.startswith("strategy_"):
                                clean_name = strategy_name[9:]  # Remove 'strategy_' prefix
                                strategy_func = getattr(module, clean_name, None)
                            
                            if strategy_func is None:
                                print(f"âŒ Function '{strategy_name}' not found in module strategies.{strategy_name}")
                                continue
                            
                            # Process all candles
                            candle_count = len(df)
                            print(f"Generating signals for {candle_count} candles...")
                            
                            # For very large datasets, just print samples and count signals
                            signal_samples = min(10, candle_count)
                            print_interval = max(1, candle_count // 10)  # Print 10% of signals
                            
                            for i in range(candle_count):
                                candle = df.iloc[i]
                                # Call strategy function
                                try:
                                    # Call the function directly
                                    result = strategy_func(candle, index_name)
                                except Exception as e:
                                    print(f"âŒ Error executing {strategy_name} for candle {i}: {e}")
                                    # Use a default result with no trade signal
                                    result = {'signal': 'NO TRADE'}
                                
                                # Rest of the code remains the same
                                signal = result.get('signal', 'NO TRADE')
                                price = candle['close']
                                confidence = result.get('confidence', 'Low')
                                
                                # Count signal types
                                signal_count[signal] = signal_count.get(signal, 0) + 1
                                
                                # Record the signal
                                signal_info = {
                                    'time': candle['time'].strftime('%Y-%m-%d %H:%M:%S'),
                                    'signal': signal,
                                    'price': price,
                                    'confidence': confidence,
                                    'index_name': index_name  # Explicitly set index_name
                                }
                                
                                # Add other fields available in result
                                for key, value in result.items():
                                    if key not in ['time'] and key not in signal_info:
                                        signal_info[key] = value
                                
                                all_signals.append(signal_info)
                                
                                # Print some samples
                                if i >= candle_count - signal_samples or i % print_interval == 0:
                                    # print(f"Time: {candle['time']} - Signal: {signal} (Price: {price:.2f})")
                                    pass
                        except ImportError as e:
                            print(f"âŒ Error importing strategy module: {e}")
                            continue
                    else:
                        print(f"âŒ Strategy file for '{strategy_name}' not found")
                        continue
                        
                    # Display signal distribution
                    # print(f"\nðŸ“Š Signal Distribution:")
                    for signal_type, count in signal_count.items():
                        percentage = (count / candle_count) * 100 if candle_count > 0 else 0
                        # print(f"{signal_type}: {count} ({percentage:.1f}%)")
                    
                    # Save signals to database if requested
                    if save_to_db and all_signals:
                        try:
                            from db import log_strategy_sql
                            
                            # Filter out NO TRADE signals for database logging
                            trading_signals = [s for s in all_signals if s.get('signal') != 'NO TRADE']
                            
                            records_saved = 0
                            if trading_signals:
                                # print(f"ðŸ”„ Saving {len(trading_signals)} trading signals to database table '{strategy_name}'...")
                                for signal_info in trading_signals:
                                    try:
                                        # Log to the database using the strategy-specific function
                                        log_strategy_sql(strategy_name, signal_info)
                                        records_saved += 1
                                    except Exception as e:
                                        print(f"âŒ Error saving signal to database: {e}")
                                        continue
                                
                                # print(f"âœ… Saved {records_saved} signals to database table '{strategy_name}'")
                            else:
                                # print(f"â„¹ï¸ No trading signals (BUY CALL/BUY PUT) to save for '{strategy_name}'")
                                pass
                            
                            strategy_results[index_name] = {
                                'candles': candle_count,
                                'signals': signal_count,
                                'records_saved': records_saved
                            }
                        except Exception as e:
                            print(f"âŒ Error accessing database module: {e}")
                            strategy_results[index_name] = {
                                'candles': candle_count,
                                'signals': signal_count,
                                'records_saved': 0
                            }
                    else:
                        strategy_results[index_name] = {
                            'candles': candle_count,
                            'signals': signal_count
                        }
                    
                except Exception as e:
                    print(f"âŒ Error processing {index_name} with strategy {strategy_name}: {e}")
                    traceback.print_exc()
            
            results[strategy_name] = strategy_results
            print(f"====== Completed: {strategy_name} ======\n")
            
        except Exception as e:
            print(f"âŒ Strategy {strategy_name} failed with error: {e}")
            traceback.print_exc()
            results[strategy_name] = {"error": str(e)}
    
    # Final summary
    end_time = time.time()
    duration = end_time - start_time
    
    print("\nðŸ“Š Overall Execution Summary:")
    print(f"Total strategies: {len(strategies)}")
    print(f"Execution time: {duration:.2f} seconds")
    print("\nResults by strategy:")
    
    for strategy_name, strategy_results in results.items():
        print(f"\n  - {strategy_name}:")
        if "error" in strategy_results:
            print(f"    ERROR: {strategy_results['error']}")
        else:
            for index_name, result in strategy_results.items():
                print(f"    {index_name}:")
                print(f"      Candles analyzed: {result['candles']}")
                print("      Signal distribution:")
                for signal_type, count in result['signals'].items():
                    percentage = (count / result['candles']) * 100 if result['candles'] > 0 else 0
                    print(f"        {signal_type}: {count} ({percentage:.1f}%)")
                if 'records_saved' in result:
                    print(f"      Results saved to database: {result['records_saved']} records")
    
    return True

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Run all trading strategies and save results to database')
    parser.add_argument('--days', type=int, default=5, help='Number of days to backtest')
    parser.add_argument('--resolution', type=str, default='15', help='Candle resolution in minutes (1, 5, 15, 30, 60, D)')
    parser.add_argument('--no-save', action='store_true', help="Don't save results to database")
    parser.add_argument('--symbols', type=str, help='Symbols to test, comma separated (default: NIFTY50,BANKNIFTY)')
    
    args = parser.parse_args()
    
    # Process symbols if provided
    symbols = None
    if args.symbols:
        symbol_list = args.symbols.split(',')
        symbols = {}
        for symbol in symbol_list:
            symbol = symbol.strip().upper()
            if symbol == 'NIFTY50':
                symbols["NSE:NIFTY50-INDEX"] = "NIFTY50"
            elif symbol == 'BANKNIFTY':
                symbols["NSE:NIFTYBANK-INDEX"] = "BANKNIFTY"
            else:
                # Assume it's a stock
                symbols[f"NSE:{symbol}-EQ"] = symbol
    
    # Run all strategies
    success = run_all_strategies(
        days_back=args.days,
        resolution=args.resolution,
        save_to_db=not args.no_save,
        symbols=symbols
    )
    
    sys.exit(0 if success else 1) 